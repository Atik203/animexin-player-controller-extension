<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AnimeXin Streaming Interface</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
        min-height: 100vh;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .url-input-section {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 30px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .input-group {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
      }

      .url-input {
        flex: 1;
        padding: 15px 20px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        font-size: 16px;
        transition: all 0.3s ease;
      }

      .url-input:focus {
        outline: none;
        border-color: #fff;
        background: rgba(255, 255, 255, 0.2);
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
      }

      .url-input::placeholder {
        color: rgba(255, 255, 255, 0.7);
      }

      .load-btn {
        padding: 15px 30px;
        background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        color: #fff;
        border: none;
        border-radius: 10px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        white-space: nowrap;
      }

      .load-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
      }

      .load-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .episode-info {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 15px;
        align-items: center;
        margin-bottom: 20px;
      }

      .episode-title {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .server-select {
        padding: 10px 15px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        font-size: 14px;
      }

      .server-select option {
        background: #333;
        color: #fff;
      }

      .nav-controls {
        display: flex;
        gap: 10px;
      }

      .nav-btn {
        padding: 10px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #fff;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .nav-btn:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }

      .nav-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .player-container {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        position: relative;
        overflow: hidden;
      }

      .video-wrapper {
        position: relative;
        width: 85%;
        margin: 0 auto;
        height: 80vh;
        min-height: 500px;
        max-height: 700px;
        border-radius: 10px;
        overflow: hidden;
        background: #000;
      }

      .video-frame {
        width: 100%;
        height: 100%;
        border: none;
        border-radius: 10px;
      }

      .video-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        border-radius: 10px;
      }

      .controls-panel {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 25px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .controls-title {
        font-size: 1.3rem;
        margin-bottom: 20px;
        text-align: center;
      }

      .control-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }

      .control-item {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .control-label {
        font-size: 14px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.9);
      }

      .control-input {
        padding: 10px 15px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        font-size: 14px;
        transition: all 0.3s ease;
      }

      .control-input:focus {
        outline: none;
        border-color: #fff;
        background: rgba(255, 255, 255, 0.2);
      }

      .control-input::placeholder {
        color: rgba(255, 255, 255, 0.6);
      }

      .action-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
      }

      .action-btn {
        padding: 12px 25px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .save-btn {
        background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        color: #fff;
      }

      .skip-btn {
        background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        color: #fff;
      }

      .fullscreen-btn {
        background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
        color: #fff;
      }

      .action-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      }

      .status-bar {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 10px 20px;
        border-radius: 25px;
        font-size: 14px;
        display: none;
        z-index: 1000;
      }

      .loading {
        opacity: 0.7;
        pointer-events: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 15px;
        }

        .input-group {
          flex-direction: column;
        }

        .episode-info {
          grid-template-columns: 1fr;
          gap: 10px;
        }

        .control-group {
          grid-template-columns: 1fr;
        }

        .action-buttons {
          flex-direction: column;
        }

        .video-wrapper {
          width: 95%;
          height: 60vh;
          min-height: 350px;
          max-height: 500px;
        }
      }

      /* Loading animation */
      .loading-spinner {
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top: 3px solid #fff;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Success/Error notifications */
      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 25px;
        border-radius: 10px;
        color: #fff;
        font-weight: 600;
        z-index: 1000;
        animation: slideIn 0.3s ease;
      }

      .notification.success {
        background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      }

      .notification.error {
        background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
      }

      .notification.info {
        background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üé¨ AnimeXin Streaming Interface</h1>
        <p>Advanced anime streaming with intro/outro skip functionality</p>
      </div>

      <div class="url-input-section">
        <div class="input-group">
          <input
            type="url"
            class="url-input"
            id="animeUrl"
            placeholder="Enter AnimeXin episode URL (e.g., https://animexin.dev/martial-master-episode-446-indonesia-english-sub/)"
            value="https://animexin.dev/martial-master-episode-446-indonesia-english-sub/"
          />
          <button class="load-btn" id="loadBtn">üöÄ Load Episode</button>
        </div>

        <div class="episode-info" id="episodeInfo" style="display: none">
          <div class="episode-title" id="episodeTitle">Loading...</div>
          <select class="server-select" id="serverSelect">
            <option value="">Select Server</option>
          </select>
          <div class="nav-controls">
            <button class="nav-btn" id="prevBtn" disabled>‚èÆÔ∏è Previous</button>
            <button class="nav-btn" id="nextBtn" disabled>Next ‚è≠Ô∏è</button>
          </div>
        </div>
      </div>

      <div class="player-container">
        <div class="video-wrapper">
          <div class="video-overlay" id="videoOverlay">
            Enter an AnimeXin URL above to start streaming
          </div>
          <iframe
            class="video-frame"
            id="videoFrame"
            style="display: none"
            allowfullscreen
            sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-presentation allow-top-navigation-by-user-activation allow-pointer-lock"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen; microphone; camera"
            loading="lazy"
          >
          </iframe>
        </div>
      </div>

      <div class="controls-panel">
        <h3 class="controls-title">‚öôÔ∏è Intro/Outro Skip Controls</h3>

        <div class="control-group">
          <div class="control-item">
            <label class="control-label">Intro Start Time (mm:ss)</label>
            <input
              type="text"
              class="control-input"
              id="introTime"
              placeholder="e.g., 1:30"
            />
          </div>
          <div class="control-item">
            <label class="control-label">Outro Start Time (mm:ss)</label>
            <input
              type="text"
              class="control-input"
              id="outroTime"
              placeholder="e.g., 17:49"
            />
          </div>
        </div>

        <div class="action-buttons">
          <button class="action-btn save-btn" id="saveBtn">
            üíæ Save Settings
          </button>
          <button class="action-btn skip-btn" id="skipIntroBtn">
            ‚è© Manual Skip Intro
          </button>
          <button class="action-btn fullscreen-btn" id="fullscreenBtn">
            üî≥ Force Fullscreen
          </button>
          <button
            class="action-btn"
            id="reloadBtn"
            style="
              background: linear-gradient(135deg, #9c27b0 0%, #673ab7 100%);
            "
          >
            üîÑ Reload Video
          </button>
        </div>
      </div>
    </div>

    <div class="status-bar" id="statusBar"></div>

    <script>
      class AnimeStreamingInterface {
        constructor() {
          this.currentEpisode = null;
          this.currentSeries = null;
          this.servers = [];
          this.videoStartTime = null;
          this.skipTimers = [];
          this.autoNextTimer = null;
          this.skipOverlay = null;
          this.setupEventListeners();
          this.loadSavedSettings();
          this.createSkipOverlay();
        }

        setupEventListeners() {
          // Load episode button
          document.getElementById("loadBtn").addEventListener("click", () => {
            this.loadEpisode();
          });

          // Enter key on URL input
          document
            .getElementById("animeUrl")
            .addEventListener("keypress", (e) => {
              if (e.key === "Enter") {
                this.loadEpisode();
              }
            });

          // Server selection
          document
            .getElementById("serverSelect")
            .addEventListener("change", (e) => {
              this.loadServer(e.target.value);
            });

          // Navigation buttons
          document.getElementById("prevBtn").addEventListener("click", () => {
            this.navigateEpisode("prev");
          });

          document.getElementById("nextBtn").addEventListener("click", () => {
            this.navigateEpisode("next");
          });

          // Control buttons
          document.getElementById("saveBtn").addEventListener("click", () => {
            this.saveSettings();
          });

          document
            .getElementById("skipIntroBtn")
            .addEventListener("click", () => {
              this.skipIntro();
            });

          document
            .getElementById("fullscreenBtn")
            .addEventListener("click", () => {
              this.forceFullscreen();
            });

          document.getElementById("reloadBtn").addEventListener("click", () => {
            this.reloadVideo();
          });
        }

        async loadEpisode() {
          const urlInput = document.getElementById("animeUrl");
          const url = urlInput.value.trim();

          if (!url) {
            this.showNotification("Please enter a valid AnimeXin URL", "error");
            return;
          }

          if (!url.includes("animexin.dev")) {
            this.showNotification("Please enter a valid AnimeXin URL", "error");
            return;
          }

          this.setLoading(true);
          this.showStatus("Loading episode data...");

          try {
            const episodeData = await this.scrapeEpisodeData(url);
            this.currentEpisode = episodeData;
            this.currentSeries = this.extractSeriesName(url);

            this.displayEpisodeInfo(episodeData);
            this.populateServers(episodeData.servers);
            this.loadSavedSettings();

            // Auto-select preferred server
            this.autoSelectServer();

            this.showNotification("Episode loaded successfully!", "success");
          } catch (error) {
            console.error("Error loading episode:", error);
            this.showNotification(
              "Failed to load episode. Please check the URL.",
              "error"
            );
          } finally {
            this.setLoading(false);
            this.hideStatus();
          }
        }

        async scrapeEpisodeData(url) {
          try {
            // Call our backend scraper API
            const apiUrl = `/api/scrape?url=${encodeURIComponent(url)}`;
            console.log("Calling scraper API:", apiUrl);

            const response = await fetch(apiUrl);
            const result = await response.json();

            console.log("Scraper response:", result);

            if (!result.success) {
              throw new Error(result.error || "Failed to scrape episode data");
            }

            // Validate that we have servers with URLs
            if (!result.data.servers || result.data.servers.length === 0) {
              throw new Error("No video servers found on the page");
            }

            const validServers = result.data.servers.filter(
              (server) => server.url
            );
            if (validServers.length === 0) {
              throw new Error("No valid video URLs found");
            }

            result.data.servers = validServers;
            return result.data;
          } catch (error) {
            console.error("Scraping error:", error);
            this.showNotification(`Scraping failed: ${error.message}`, "error");

            // Fallback to mock data if backend fails
            const episodeMatch = url.match(/episode-(\d+)/);
            const episodeNumber = episodeMatch ? parseInt(episodeMatch[1]) : 1;

            return {
              title: `Episode ${episodeNumber} (Offline Mode)`,
              episode: episodeNumber,
              series: this.extractSeriesName(url),
              servers: [
                {
                  name: "Hardsub English Dailymotion (Demo)",
                  url: "https://www.dailymotion.com/embed/video/k5wZqkP7tJ7C3gAUVtE",
                  preferred: true,
                },
              ],
              prevUrl:
                episodeNumber > 1
                  ? url.replace(
                      `episode-${episodeNumber}`,
                      `episode-${episodeNumber - 1}`
                    )
                  : null,
              nextUrl: url.replace(
                `episode-${episodeNumber}`,
                `episode-${episodeNumber + 1}`
              ),
            };
          }
        }

        displayEpisodeInfo(episodeData) {
          document.getElementById("episodeTitle").textContent =
            episodeData.title;
          document.getElementById("episodeInfo").style.display = "grid";

          // Update navigation buttons
          const prevBtn = document.getElementById("prevBtn");
          const nextBtn = document.getElementById("nextBtn");

          prevBtn.disabled = !episodeData.prevUrl;
          nextBtn.disabled = false; // Always allow next (even if doesn't exist)
        }

        populateServers(servers) {
          const serverSelect = document.getElementById("serverSelect");
          serverSelect.innerHTML = '<option value="">Select Server</option>';

          servers.forEach((server, index) => {
            const option = document.createElement("option");
            option.value = index;
            option.textContent = server.name;
            serverSelect.appendChild(option);
          });

          this.servers = servers;
        }

        autoSelectServer() {
          // Auto-select preferred server based on user preference
          const preferredIndex = this.servers.findIndex(
            (server) => server.preferred
          );

          if (preferredIndex !== -1) {
            document.getElementById("serverSelect").value = preferredIndex;
            this.loadServer(preferredIndex);
          } else if (this.servers.length > 0) {
            // Fallback to first available server
            document.getElementById("serverSelect").value = 0;
            this.loadServer(0);
          }
        }

        loadServer(serverIndex) {
          if (serverIndex === "" || !this.servers[serverIndex]) {
            this.hideVideo();
            return;
          }

          const server = this.servers[serverIndex];

          if (!server.url) {
            this.showNotification(
              `No URL available for ${server.name}`,
              "error"
            );
            this.hideVideo();
            return;
          }

          console.log(`Loading server: ${server.name} with URL: ${server.url}`);
          this.showVideo(server.url);
          this.showNotification(`Loaded: ${server.name}`, "success");
        }

        showVideo(url) {
          const videoFrame = document.getElementById("videoFrame");
          const videoOverlay = document.getElementById("videoOverlay");

          videoFrame.src = url;
          videoFrame.style.display = "block";
          videoOverlay.style.display = "none";

          // Reset video start time and setup skip functionality
          this.videoStartTime = Date.now();
          this.clearSkipTimers();
          this.setupSkipTimers();

          // Show helpful instructions
          this.showNotification(
            "üé¨ Video loaded! Auto-skip and auto-next will work automatically. For volume control, right-click on video.",
            "info",
            8000
          );
        }

        hideVideo() {
          const videoFrame = document.getElementById("videoFrame");
          const videoOverlay = document.getElementById("videoOverlay");

          videoFrame.src = "";
          videoFrame.style.display = "none";
          videoOverlay.style.display = "flex";
          videoOverlay.textContent = "Select a server to start streaming";
        }

        extractSeriesName(url) {
          try {
            const path = new URL(url).pathname.replace(/^\/+|\/+$/g, "");
            const base = path.split("/")[0];
            const idx = base.indexOf("-episode-");
            return idx > 0 ? base.substring(0, idx) : base;
          } catch (e) {
            return "unknown";
          }
        }

        async navigateEpisode(direction) {
          if (!this.currentEpisode) return;

          const targetUrl =
            direction === "prev"
              ? this.currentEpisode.prevUrl
              : this.currentEpisode.nextUrl;

          if (!targetUrl) {
            this.showNotification(`No ${direction} episode available`, "error");
            return;
          }

          // Clear existing timers before navigation
          this.clearSkipTimers();

          document.getElementById("animeUrl").value = targetUrl;
          await this.loadEpisode();
        }

        async navigateToNextEpisode() {
          await this.navigateEpisode("next");
        }

        saveSettings() {
          const introTime = document.getElementById("introTime").value;
          const outroTime = document.getElementById("outroTime").value;

          if (!this.currentSeries) {
            this.showNotification("Please load an episode first", "error");
            return;
          }

          const settings = {
            introTime: this.parseTime(introTime),
            outroTime: this.parseTime(outroTime),
            timestamp: Date.now(),
          };

          localStorage.setItem(
            `anime_settings_${this.currentSeries}`,
            JSON.stringify(settings)
          );

          console.log(`Settings saved for ${this.currentSeries}:`, settings);
          this.showNotification(
            `‚úÖ Settings saved! Intro: ${introTime}, Outro: ${outroTime}`,
            "success"
          );

          // Re-setup timers with new settings
          this.clearSkipTimers();
          this.setupSkipTimers();
        }

        loadSavedSettings() {
          if (!this.currentSeries) return;

          const saved = localStorage.getItem(
            `anime_settings_${this.currentSeries}`
          );
          if (saved) {
            try {
              const settings = JSON.parse(saved);
              document.getElementById("introTime").value = this.formatTime(
                settings.introTime || 0
              );
              document.getElementById("outroTime").value = this.formatTime(
                settings.outroTime || 0
              );
            } catch (e) {
              console.error("Error loading settings:", e);
            }
          }
        }

        createSkipOverlay() {
          this.skipOverlay = document.createElement("div");
          this.skipOverlay.id = "skipOverlay";
          this.skipOverlay.style.cssText = `
             position: absolute;
             top: 20px;
             right: 20px;
             background: rgba(0, 0, 0, 0.8);
             color: white;
             padding: 15px 25px;
             border-radius: 25px;
             font-weight: 600;
             z-index: 1000;
             display: none;
             cursor: pointer;
             transition: all 0.3s ease;
             border: 2px solid #667eea;
           `;

          const videoWrapper = document.querySelector(".video-wrapper");
          videoWrapper.appendChild(this.skipOverlay);

          this.skipOverlay.addEventListener("click", () => {
            this.handleSkipClick();
          });
        }

        setupSkipTimers() {
          const introTime = this.parseTime(
            document.getElementById("introTime").value
          );
          const outroTime = this.parseTime(
            document.getElementById("outroTime").value
          );

          const isDM = this.isDailymotionActive();
          console.log(
            `Setting up click-sim timers (DM=${isDM}) - Intro: ${introTime}s, Outro: ${outroTime}s`
          );

          // Notify a few seconds before intro skip
          if (introTime > 3) {
            const notifyIntro = setTimeout(() => {
              this.showNotification("Auto-skipping intro in 3 seconds...", "info");
            }, (introTime - 3) * 1000);
            this.skipTimers.push(notifyIntro);
          }

          // Simulate clicking the Manual Skip Intro button at intro time
          if (introTime > 0) {
            const clickSkip = setTimeout(() => {
              if (isDM) {
                console.log("[Auto] Clicking Skip Intro button");
                this.simulateClick('skipIntroBtn');
              } else {
                console.log("[Auto] Non-DM source, invoking skipIntro()");
                this.skipIntro();
              }
            }, introTime * 1000);
            this.skipTimers.push(clickSkip);

            // Then simulate clicking Force Fullscreen shortly after
            const clickFullscreen = setTimeout(() => {
              console.log("[Auto] Clicking Force Fullscreen button");
              this.simulateClick('fullscreenBtn');
            }, introTime * 1000 + 800);
            this.skipTimers.push(clickFullscreen);
          }

          // Notify at outro
          if (outroTime > 0) {
            const notifyOutro = setTimeout(() => {
              this.showNotification("Outro reached - preparing auto-next...", "info");
            }, outroTime * 1000);
            this.skipTimers.push(notifyOutro);

            // Exit fullscreen at outro
            const exitFs = setTimeout(() => {
              console.log("[Auto] Exiting fullscreen at outro");
              this.exitFullscreenIfNeeded();
            }, outroTime * 1000);
            this.skipTimers.push(exitFs);

            // Click Next button shortly after
            const clickNext = setTimeout(() => {
              console.log("[Auto] Clicking Next button");
              this.simulateClick('nextBtn');
            }, outroTime * 1000 + 1500);
            this.skipTimers.push(clickNext);
          }
        }

        autoSkipIntro() {
          const introTime = document.getElementById("introTime").value;
          if (introTime) {
            console.log("Executing auto intro skip...");
            this.skipIntro();

            // Force fullscreen immediately after skip
            setTimeout(() => {
              this.forceFullscreen();
            }, 1000);
          }
        }

        forceFullscreen() {
          console.log("Attempting force fullscreen...");
          
          // Try multiple approaches for fullscreen
          const videoFrame = document.getElementById("videoFrame");
          const videoWrapper = document.querySelector(".video-wrapper");
          const playerContainer = document.querySelector(".player-container");
          
          if (!document.fullscreenElement) {
            // Try iframe first
            videoFrame.requestFullscreen().then(() => {
              console.log("Iframe fullscreen success");
              this.showNotification("Auto-fullscreen activated!", "success");
            }).catch(() => {
              console.log("Iframe fullscreen failed, trying video wrapper...");
              // Try video wrapper
              videoWrapper.requestFullscreen().then(() => {
                console.log("Video wrapper fullscreen success");
                this.showNotification("Auto-fullscreen activated!", "success");
              }).catch(() => {
                console.log("Video wrapper fullscreen failed, trying player container...");
                // Try player container
                playerContainer.requestFullscreen().then(() => {
                  console.log("Player container fullscreen success");
                  this.showNotification("Auto-fullscreen activated!", "success");
                }).catch(() => {
                  console.log("All fullscreen attempts failed");
                  this.showNotification("Fullscreen not available - please click fullscreen button manually", "error");
                });
              });
            });
          }
        }

        // Helper: determine if current player is Dailymotion
        isDailymotionActive() {
          try {
            const src = document.getElementById('videoFrame')?.src || '';
            return src.includes('dailymotion.com');
          } catch {
            return false;
          }
        }

        // Helper: simulate a click on a button by id
        simulateClick(elementId) {
          const el = document.getElementById(elementId);
          if (!el) return;
          try {
            const evt = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
            el.dispatchEvent(evt);
          } catch {
            // Fallback
            el.click?.();
          }
        }

        // Helper: exit fullscreen if active
        exitFullscreenIfNeeded() {
          if (document.fullscreenElement) {
            try { document.exitFullscreen(); } catch {}
          }
        }

        showSkipButton(text, type) {
          this.skipOverlay.innerHTML = `
             <div style="display: flex; align-items: center; gap: 10px;">
               <span>${text}</span>
               <span id="skipCountdown" style="background: #667eea; padding: 2px 8px; border-radius: 10px; font-size: 12px;">10</span>
             </div>
           `;
          this.skipOverlay.dataset.type = type;
          this.skipOverlay.style.display = "block";

          // Countdown timer
          let countdown = 10;
          const countdownEl = this.skipOverlay.querySelector("#skipCountdown");
          const countdownInterval = setInterval(() => {
            countdown--;
            if (countdownEl) {
              countdownEl.textContent = countdown;
            }
            if (countdown <= 0) {
              clearInterval(countdownInterval);
              this.skipOverlay.style.display = "none";
            }
          }, 1000);
        }

        handleSkipClick() {
          const type = this.skipOverlay.dataset.type;

          if (type === "intro") {
            this.skipIntro();
          } else if (type === "outro") {
            this.navigateToNextEpisode();
          }

          this.skipOverlay.style.display = "none";
        }

        autoNavigateNext() {
          if (this.currentEpisode && this.currentEpisode.nextUrl) {
            this.showNotification(
              "üé¨ AUTO-LOADING NEXT EPISODE...",
              "info",
              5000
            );

            // Clear all timers to prevent conflicts
            this.clearSkipTimers();

            // Navigate to next episode
            setTimeout(() => {
              console.log("Executing auto-next episode navigation");
              this.navigateEpisode("next");
            }, 2000);
          } else {
            this.showNotification("üîö No more episodes available", "error");
            console.log("No next episode URL available");
          }
        }

        reloadVideo() {
          const videoFrame = document.getElementById("videoFrame");
          const currentUrl = videoFrame.src;

          if (currentUrl) {
            this.showNotification("üîÑ Reloading video...", "info");
            videoFrame.src = "";
            setTimeout(() => {
              videoFrame.src = currentUrl;
              this.showNotification("‚úÖ Video reloaded!", "success");
            }, 500);
          } else {
            this.showNotification("‚ùå No video to reload", "error");
          }
        }

        clearSkipTimers() {
          this.skipTimers.forEach((timer) => clearTimeout(timer));
          this.skipTimers = [];
          if (this.skipOverlay) {
            this.skipOverlay.style.display = "none";
          }
        }

        skipIntro() {
          const introTime = document.getElementById("introTime").value;
          if (!introTime) {
            this.showNotification("Please set intro time first", "error");
            return;
          }

          this.showNotification(
            `Auto-skipping intro to ${introTime}`,
            "success"
          );

          const videoFrame = document.getElementById("videoFrame");
          const currentUrl = videoFrame.src;
          const introSeconds = this.parseTime(introTime);

          if (currentUrl.includes("dailymotion.com")) {
            // For Dailymotion: Add start parameter
            const newUrl = currentUrl.includes("?")
              ? `${currentUrl}&start=${introSeconds}`
              : `${currentUrl}?start=${introSeconds}`;
            console.log(`Reloading Dailymotion with timestamp: ${newUrl}`);
            videoFrame.src = newUrl;
          } else if (currentUrl.includes("ok.ru")) {
            // For OK.ru: Try to add timestamp (not always supported)
            const newUrl = currentUrl.includes("?")
              ? `${currentUrl}&t=${introSeconds}`
              : `${currentUrl}?t=${introSeconds}`;
            console.log(`